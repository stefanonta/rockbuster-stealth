-- Which movies contributed the most to revenue?
SELECT f.title, SUM(p.amount) AS total_revenue
FROM film AS f
INNER JOIN inventory AS i USING(film_id)
INNER JOIN rental AS r USING(inventory_id)
INNER JOIN payment AS p USING(rental_id)
GROUP BY f.title
ORDER BY total_revenue DESC;

-- What was the average rental duration for all videos?
SELECT ROUND(
       AVG( date_part('epoch', (return_date - rental_date)) )::numeric -- convert to numeric as ROUND() in postgres 
	                                                                   -- does not accept double precisions types
       / 60   -- to minutes
       / 60   -- to hours
       / 24,  -- to days
       2) 
       || ' Days' AS days
FROM rental;

-- Which countries are Rockbuster customers based in?
SELECT DISTINCT country
FROM customer AS c
INNER JOIN address AS a USING(address_id)
INNER JOIN city AS cty USING(city_id)
INNER JOIN country AS ctr USING(country_id)
ORDER BY country;


-- Where are customers with a high lifetime value based?
-- High CLV is defined as CLV > (mean + 2 * standard deviation)
WITH customer_clv AS (
	SELECT customer_id,
	       address_id,
	       first_name,
		   last_name,
		   SUM(amount) AS clv,
		   PERCENT_RANK() OVER(ORDER BY SUM(amount)) * 100 AS percentile
	FROM payment
    INNER JOIN customer USING(customer_id)
	GROUP BY 1, 2, 3
)
SELECT customer_id,
       country,
	   city,
	   clv,
	   ROUND(percentile::numeric, 2) AS percentile
FROM customer_clv
INNER JOIN address a USING(address_id)
INNER JOIN city cty USING(city_id)
INNER JOIN country cnt USING(country_id)
-- use subquey to retrieve the treshold to consider customers high LTV
WHERE clv > (SELECT AVG(clv) + 2 * STDDEV(clv) 
               FROM customer_clv
			   )
ORDER BY 2,3;


-- Do sales figures vary between geographic regions?
SELECT cnt.country, 
       TO_CHAR(SUM(p.amount), 'FM$ 999,999') AS revenue,
	   COUNT(p.payment_id) AS total_num_rentals,
	   -- Added avg to understand if high revenue is due to expensive rental, or the high volume. 
	   '$ ' || ROUND(AVG(p.amount), 2) AS average_spending
FROM payment p
INNER JOIN customer c USING(customer_id)
INNER JOIN address a USING(address_id)
INNER JOIN city cty USING(city_id)
INNER JOIN country cnt USING(country_id)
GROUP BY cnt.country
ORDER BY SUM(p.amount) DESC;


-- Which 10 customers have spent the most money on rentals?
SELECT first_name, last_name, SUM(amount) AS total_spend 
FROM customer
INNER JOIN payment USING(customer_id)
GROUP BY first_name, last_name
ORDER BY total_spend DESC
LIMIT 10;


-- What percentage of total revenue is generated by the top 5% of customers?
WITH customers_amount AS (
	SELECT customer_id,
		   SUM(amount) AS total_amount_purchased
	FROM payment AS p
	INNER JOIN customer AS c USING(customer_id)
	GROUP BY customer_id
),
ranked_customers AS (
	SELECT customer_id,
		   total_amount_purchased,
		   -- divide customers into 20 buckets (100/5=20) so the 20th bucket represent the top 5% by generated revenue
		   NTILE(20) OVER(ORDER BY total_amount_purchased) AS percentile_rank
	FROM customers_amount
)

SELECT ROUND( SUM(total_amount_purchased) / 
                  -- subquery to select the total revenue
				  (SELECT SUM(amount) 
		          FROM payment), 2) * 100 || '%' AS top5_percentage
FROM ranked_customers
WHERE percentile_rank = 20;


-- Which customers are renting frequently but spending less?
WITH rent_info AS (
	SELECT p.customer_id,
	       rental_id,
		   rental_date,
		   return_date,
		   amount
	FROM rental AS r
	INNER JOIN customer AS c USING(customer_id)
	INNER JOIN payment AS p USING (rental_id)
	ORDER BY p.customer_id
	),
frequent_low_spenders AS(
	SELECT customer_id,
	       DATE_TRUNC('month', rental_date) AS rental_month,
	       COUNT(rental_id) AS num_of_rentals,
		   SUM(amount) AS total_spent,
		   AVG(amount) AS avg_spent_per_rental
	FROM rent_info
	GROUP BY customer_id, rental_month
	-- I assume "frequently" is at least 8 rent per month
	HAVING COUNT(rental_id) >= 8
	ORDER BY total_spent
	)
SELECT customer_id, 
       first_name,
	   last_name,
	   num_of_rentals,
	   total_spent,
	   ROUND(avg_spent_per_rental, 2) AS avg_spent_per_rental
FROM frequent_low_spenders
INNER JOIN customer USING(customer_id)
ORDER BY total_spent;


-- Find customers who have never returned a rental on time
WITH rentals AS(
	SELECT r.customer_id,
	       r.rental_date,
		   r.return_date,
		   i.inventory_id,
		   i.film_id,
		   f.rental_duration
	FROM rental AS r
	INNER JOIN inventory AS i USING(inventory_id)
	INNER JOIN film AS f USING(film_id)
),
late_flag AS(
	SELECT customer_id,
	       DATE_PART('day', (return_date - rental_date)::interval) AS interval_rental_duration,
		   rental_duration,
		   -- if the customer's rental day > rental_duration allowed then flagged as late (1)
		   CASE WHEN DATE_PART('day', (return_date - rental_date)::interval) > rental_duration
		        THEN 1
		        ELSE 0
				END AS Late_Flag
	FROM rentals
)
SELECT customer_id, 
       SUM(late_flag) AS num_of_late_returns
FROM late_flag
GROUP BY customer_id
-- if a customer always returned late then the sum of late flags must be equal to their total number of rentals
HAVING SUM(late_flag) = COUNT(*);


-- What is the customer lifetime value (CLV) of each customer?
/*
NOTE
Since Rockbusterâ€™s dataset only includes historical payments, CLV is calculated as the total amount paid by each customer to date. 
This gives us a solid baseline to identify high-value customers based on real revenue.
*/
SELECT customer_id,
       first_name,
	   last_name,
       SUM(amount) AS clv
FROM payment
INNER JOIN customer USING(customer_id)
GROUP BY customer_id, first_name, last_name
ORDER BY 1;


-- Identify inactive customers (those who have not rented in the last 6 months).
-- The latest rental date will be used as reference date for the last 6 months
WITH latest_rent_date AS (
	SELECT customer_id,
	       MAX(rental_date) AS most_recent_rent
	FROM rental
	GROUP BY customer_id
)
SELECT customer_id,
       first_name,
	   last_name
FROM latest_rent_date
INNER JOIN customer USING(customer_id)
WHERE most_recent_rent < (SELECT MAX(rental_date) - CAST('6 month' AS interval) 
                          FROM rental);

						  
-- What is the most common rental duration for movies?
WITH duration_info AS (
	SELECT rental_id,
	       customer_id,
	       (return_date - rental_date) AS rental_duration,
		   date_part('hour', (return_date - rental_date)) AS hour_part
	FROM rental
	),
days_duration AS( 
	SELECT rental_id,
	       rental_duration,
		   -- day duration are calculated based on the hour's part of the interval. If >12 then +1 day.
	       CASE WHEN hour_part > 12 THEN DATE_PART('day', rental_duration) + 1
		        ELSE DATE_PART('day', rental_duration)
		        END AS days_rental_duration
	FROM duration_info
	),

bins AS (
	SELECT generate_series(1,7,3) AS lower_day,
           generate_series(4,10,3) AS upper_day
	)
SELECT days_rental_duration,
       -- include null values in the count to see how many have missing dates
       COUNT(*) AS frequency
FROM days_duration
GROUP BY 1
ORDER BY 2 DESC;

-- We can also create a histogram with three bins

-- SELECT lower_day || ' day(s)' AS min_days_duration,
--        upper_day || ' day(s)' AS max_days_duration,
-- 	   COUNT(days_rental_duration) AS num_of_rentals
-- FROM bins b
-- LEFT JOIN days_duration d ON d.days_rental_duration >= b.lower_day
--                              AND d.days_rental_duration < b.upper_day
-- GROUP BY lower_day, upper_day
-- ORDER BY 1;


-- Compare rental frequency per category before and after a given year.
-- After verifying that only data for the years 2005-2006 are present I implemented this solution
SELECT DATE_PART('year', rental_date) AS rental_year,
	   c.name AS category,
	   COUNT(*) AS total_rentals
FROM rental AS r
INNER JOIN inventory AS i USING(inventory_id)
INNER JOIN film_category AS fc USING(film_id)
INNER JOIN category AS c USING(category_id)
GROUP BY 1, 2
ORDER BY 1,3 DESC;


-- What are the top 3 most rented movies in each store location?
WITH rentals_by_store AS (
	SELECT store_id, 
	       film_id,
		   COUNT(*) AS num_of_rentals
	FROM rental AS r
	LEFT JOIN inventory AS i USING(inventory_id)
	LEFT JOIN store AS s USING(store_id)
	GROUP BY store_id, film_id
	ORDER BY store_id, film_id, num_of_rentals DESC
	),	
movie_rank_table AS (
	SELECT *, 
	       DENSE_RANK() OVER (PARTITION BY store_id ORDER BY num_of_rentals DESC) movie_rank
	FROM rentals_by_store
	)
SELECT store_id, title, num_of_rentals, movie_rank
FROM movie_rank_table
LEFT JOIN film AS f USING (film_id)
WHERE movie_rank < 4
ORDER BY 1, 4;


-- Which staff members are handling the most rentals?
SELECT staff_id, 
       first_name,
	   last_name, 
       COUNT(rental_id) AS rentals_handled
FROM rental AS r
INNER JOIN staff AS s USING(staff_id)
GROUP BY staff_id, first_name, last_name
ORDER BY rentals_handled DESC;


-- Identify duplicate customer accounts (same name, email, but different customer_id)
SELECT lower(first_name) AS first_name,
	   lower(last_name) AS last_name,
	   lower(email) AS email,
	   CASE WHEN COUNT(customer_id) > 1 THEN 'yes'
	   ELSE 'no' END AS is_duplicated
FROM customer
GROUP BY lower(first_name),
	     lower(last_name),
	     lower(email);

-- Another version that only shows the duplicated customer records
SELECT c1.customer_id,
       lower(c1.first_name) AS first_name,
	   lower(c1.last_name) AS last_name,
	   lower(c1.email) AS email,
	   COUNT(*)
FROM customer AS c1
INNER JOIN customer AS c2 
        ON lower(c1.first_name) = lower(c2.first_name) 
	   AND lower(c1.last_name) = lower(c2.last_name)
	   AND lower(c1.email) = lower(c2.email)
	   AND c1.customer_id <> c2.customer_id
GROUP BY 1,2,3
HAVING COUNT(*) > 1;


-- Predict peak rental periods based on past rental trends
  SELECT date_part('month', rental_date) AS month,
         date_part('year', rental_date) AS year,
         COUNT(*) AS num_of_rentals
    FROM rental
GROUP BY 1,2
ORDER BY 2, 1;

